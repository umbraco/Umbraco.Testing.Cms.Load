# Repo: andr317c/load-test-pipeline
# File: azure-pipeline.yml

name: load_test_pipeline

trigger: none

pool:
  vmImage: 'ubuntu-latest'

variables:
  # Azure Service Connection (NEEDS TO BE CHANGED FROM MICROSOFT AZURE SPONSORSHIP TO UMBRACO SERVICES DEV)
  serviceConnection: 'terraform-umbraco-load-testing-az-connection'
  # Azure Resource Variables
  azureprefix: 'azure-load-tester-umbraco'
  azurergname: 'azure-andreas-load-testing-rg'
  # Terraform settings
  terraformWorkingDirectory: '$(System.DefaultWorkingDirectory)/Terraform'
  # LoadTestLocation
  loadTestFileLocation: '$(System.DefaultWorkingDirectory)/LoadTestVersions.yaml'

  # If possible in the future, get the hostnames from the terraform output and insert them automatically in the load tests, then we should also be able to input the complete version name in the runName aswell.
  # Another step that is missing is that we want to be able to load test 3-4 or more versions at once. Right now the pipeline is only able to test two, that is because we only have two load tests defined. we can manually add them now if we want. But if there is a way
  # to automatically add load tests based on the amount of version name or something. (Possibly a script that runs for each host name and inputs all the values.)
  # First load test variables
  firstVersionsName: 'v10'
  firstloadTestRunName: 'Load test for version 10.3.1'
  # Second load test variables
  secondVersionsName: 'v11'
  secondloadTestRunName: 'Load test for version 11.3.0'

stages:
- stage: terraformDeploy
  displayName: Terraform setup and apply
  jobs:
    - job: checkResourceGroup
      displayName: Checks if resource group with defined name exists
      steps:
      - task: AzureCLI@2
        name: checkGroup
        displayName: Checks if the resource group exists before running all the steps
        inputs:
         azureSubscription: '$(serviceConnection)'
         scriptType: 'pscore'
         scriptLocation: 'inlineScript'
         inlineScript: 'Write-Host "##vso[task.setvariable variable=resourceGroupExists;isOutput=true]$(az group exists -n $(azurergname))"'
    - job: setup 
      dependsOn: checkResourceGroup
      condition: eq(dependencies.checkResourceGroup.outputs['checkGroup.resourceGroupExists'], false)
      displayName: Terraform setup
      steps:
       - task: TerraformInstaller@0
         displayName: Install Terraform
         inputs:
          terraformVersion: 'latest' 
       - task: PowerShell@2
         displayName: Terraform Init
         inputs:
           targetType: 'inline'
           script: 'terraform init -backend=false'
           workingDirectory: '$(terraformWorkingDirectory)'
       - task: TerraformTaskV4@4
         displayName: Validate 
         inputs:
          provider: 'azurerm'
          command: 'validate'
          workingDirectory: '$(terraformWorkingDirectory)'
       - task: TerraformTaskV4@4
         displayName: Terraform Plan
         inputs:
          provider: 'azurerm'
          command: 'plan'
          workingDirectory: '$(terraformWorkingDirectory)'
          environmentServiceNameAzureRM: '$(serviceConnection)'
          commandOptions: '-parallelism=1 -var resource_name_prefix=$(azureprefix) -var resource_group_name=$(azurergname)'
    - job: manualValidation
      displayName: Manual validation for checking if the terraform plan is correct
      dependsOn: setup
      pool: server
      steps:
       - task: ManualValidation@0
         displayName: Waits for external validation
         inputs:
           # notifyUsers: aze@umbraco.dk
           instructions: 'Please validate that the terraform plan is correct'
    - job: apply
      displayName: Terraform Apply
      dependsOn: 
        - manualValidation 
      steps:
      # We need to initialize again, otherwise the pipeline will fail.
      - task: PowerShell@2
        displayName: Terraform Init
        inputs:
          targetType: 'inline'
          script: 'terraform init -backend=false'
          workingDirectory: '$(terraformWorkingDirectory)'
      - task: AzureCLI@2
        name: AzLoginInfo
        displayName: Get Azure Login Credentials 
        inputs:
         azureSubscription: '$(serviceConnection)'
         scriptType: bash
         scriptLocation: inlineScript
         inlineScript: |
          echo "##vso[task.setvariable variable=ARM_CLIENT_ID]$servicePrincipalId" 
            
          echo "##vso[task.setvariable variable=ARM_CLIENT_SECRET]$servicePrincipalKey"

          echo "##vso[task.setvariable variable=ARM_TENANT_ID]$tenantId"
         addSpnToEnvironment: true
      - task: TerraformTaskV4@4
        displayName: Terraform Apply
        inputs:
          provider: 'azurerm'
          command: 'apply'
          workingDirectory: '$(terraformWorkingDirectory)'
          environmentServiceNameAzureRM: '$(serviceConnection)'
          commandOptions: '-parallelism=1 -var resource_name_prefix=$(azureprefix) -var resource_group_name=$(azurergname) -var client_id=$(ARM_CLIENT_ID) -var client_secret=$(ARM_CLIENT_SECRET) -var tenant_id=$(ARM_TENANT_ID)'
      - task: TerraformTaskV4@4
        displayName: Terraform Output
        inputs:
          provider: 'azurerm'
          command: 'output'
          workingDirectory: '$(terraformWorkingDirectory)'
          environmentServiceNameAzureRM: '$(serviceConnection)'
      - task: PowerShell@2
        name: outputVars
        displayName: Terraform Output define variables
        inputs:
          targetType: 'inline'
          script: |
            Write-Host "##vso[task.setvariable variable=hostNames;isOutput=true]$(terraform output -json umbraco_version_hostnames)"

            Write-Host "##vso[task.setvariable variable=loadTestName;isOutput=true]$(terraform output -json load_test_name)"
          workingDirectory: '$(terraformWorkingDirectory)'
      - script: |
          echo "##vso[task.setvariable variable=loadTestNameScript]$(terraform output -json load_test_name)"
        displayName: Run a single line script
        workingDirectory: '$(terraformWorkingDirectory)' 
      - script: |
          echo "$(loadTestNameScript)"
        displayName: Write LoadTest output

    - job: manualValidationLoadTest
      dependsOn: apply
      displayName: Manual validation for running load tests
      pool: server
      variables:
        loadTestName: $[dependencies.apply.outputs['outputVars.loadTestName']]
        hostNames: $[dependencies.apply.outputs['outputVars.hostNames']]
      steps:
       - task: ManualValidation@0
         displayName: Wait for external validation
         inputs:
           # notifyUsers: aze@umbraco.dk
           instructions: 'Please validate that the terraform has applied as intended before running the load tests on the load test resource $(loadTestName), raw = $(loadTestNameRaw), empty = $(loadTestNameEmpty).loadTestNamereplace = $(loadTestNamereplace) HostNames = $(hostNames)'
    # At the moment the load test will only be able to test two host names. If you want to extend it to three or four, just add another task with AzureLoadTest. 
    - job: runLoadTest
      displayName: Runs the load test
      dependsOn: 
        - apply
        - manualValidationLoadTest
      variables: 
        loadTestName: $[dependencies.apply.outputs['outputVars.loadTestName']]
        hostNames: $[dependencies.apply.outputs['outputVars.hostNames']]
      steps: 
      - script: |
          echo "$(loadTestNameScripts)"
          echo "$(loadTestName)"
      - task: PowerShell@2
        inputs:
          targetType: 'inline'
          script: |
            Write-Host "$(loadTestName)"
            Write-Host '$(loadTestName)'
            Write-Host $(loadTestName)

      - task: AzureLoadTest@1
        displayName: LoadTest 1
        inputs:
          azureSubscription: '$(serviceConnection)'
          loadTestConfigFile: '$(loadTestFileLocation)'
          resourceGroup: '$(azurergname)'
          loadTestResource: "$(loadTestName)"
          loadTestRunName: '$(firstloadTestRunName)'
          loadTestRunDescription: 'We are load testing different versions of Umbraco'
          env: |
            [
              {
              "name": "hostName",
              "value": "$(azureprefix)-appservice-$(firstVersionsName).azurewebsites.net"
              }
            ]
      - task: AzureLoadTest@1
        displayName: LoadTest 2
        inputs:
          azureSubscription: '$(serviceConnection)'
          loadTestConfigFile: '$(loadTestFileLocation)'
          resourceGroup: '$(azurergname)'
          loadTestResource: $(loadTestName)
          loadTestRunName: '$(secondloadTestRunName)'
          loadTestRunDescription: 'We are load testing different versions of Umbraco'
          env: |
            [
              {
              "name": "hostName",
              "value": "$(azureprefix)-appservice-$(secondVersionName).azurewebsites.net"
              }
            ]
      # Maybe we could have 5 steps. but a load test is only gonna run if the varaibles input to the load test both arent null
      
    - job: doesResourceGroupExists
      dependsOn: runLoadTest
      condition: succeededOrFailed()
      displayName: Checks if the resource group exists
      steps:
       - task: AzureCLI@2
         name: checkResourceGroup
         displayName: Checks if the resource group exists
         inputs:
           azureSubscription: '$(serviceConnection)'
           scriptType: 'pscore'
           scriptLocation: 'inlineScript'
           inlineScript: 'Write-Host "##vso[task.setvariable variable=doesExist;isOutput=true]$(az group exists -n $(azurergname))"'
    - job: manualValidationResourceGroup
      dependsOn: doesResourceGroupExists
      condition: eq(dependencies.doesResourceGroupExists.outputs['checkResourceGroup.doesExist'], true)
      displayName: Manual validation for deleting the resource group
      pool: server
      steps:
       - task: ManualValidation@0
         displayName: Wait for external validation
         inputs:
           # notifyUsers: aze@umbraco.dk
           instructions: 'Please validate if you want to delete the resource group with the name of $(azurergname). All the content inside of the resource group will also be deleted.'

    - job: deleteResourceGroup
      displayName: Deletes the resource group
      dependsOn: manualValidationResourceGroup
      condition: eq(dependencies.manualValidationResourceGroup.result, 'succeeded')
      steps:
      - task: AzureCLI@2
        name: checkResourceGroupAgain
        displayName: Checks if the resource group exists before deleting it
        inputs:
         azureSubscription: '$(serviceConnection)'
         scriptType: 'pscore'
         scriptLocation: 'inlineScript'
         inlineScript: 'Write-Host "##vso[task.setvariable variable=doesResourceGroupExist;isOutput=true]$(az group exists -n $(azurergname))"'
      - task: AzureCLI@2
        displayName: Deletes the resource group
        retryCountOnTaskFailure: 5
        inputs:
          azureSubscription: '$(serviceConnection)'
          scriptType: 'pscore'
          scriptLocation: 'inlineScript'
          inlineScript: 'az group delete -n $(azurergname) --yes'
# Repo: andr317c/load-test-pipeline
# File: azure-pipeline.yml

name: load_test_pipeline

trigger: none

pool:
  vmImage: 'ubuntu-latest'

variables:
  # Azure Service Connection (NEEDS TO BE CHANGED FROM MICROSOFT AZURE SPONSORSHIP TO UMBRACO SERVICES DEV)
  serviceConnection: 'terraform-umbraco-load-testing-az-connection'
  # Azure Resource Variables
  azureprefix: 'azure-load-testing-umbraco'
  azurergname: 'andreas-az-load-testing-rg'
  azurelocation: 'westeurope'
  # Terraform settings
  terraformWorkingDirectory: '$(System.DefaultWorkingDirectory)/Terraform'

  # LoadTestLocation
  loadTestFileLocation: '$(System.DefaultWorkingDirectory)/LoadTestVersions.yaml'

stages:
- stage: terraformDeploy
  jobs:
    - job: setup 
      displayName: Terraform setup
      steps:
       - task: TerraformInstaller@0
         displayName: Install Terraform
         inputs:
          terraformVersion: 'latest' 
       - task: PowerShell@2
         displayName: Terraform Init
         inputs:
           targetType: 'inline'
           script: 'terraform init -backend=false'
           workingDirectory: '$(terraformWorkingDirectory)'
       - task: TerraformTaskV4@4
         displayName: Validate 
         inputs:
          provider: 'azurerm'
          command: 'validate'
          workingDirectory: '$(terraformWorkingDirectory)'
       - task: AzureCLI@2
         name: AzLoginInfo
         displayName: Gets Azure Login Credentials 
         inputs:
          azureSubscription: '$(serviceConnection)'
          scriptType: bash
          scriptLocation: inlineScript
          inlineScript: |
            echo "##vso[task.setvariable variable=ARM_CLIENT_ID]$servicePrincipalId" 
            
            echo "##vso[task.setvariable variable=ARM_CLIENT_SECRET]$servicePrincipalKey"

            echo "##vso[task.setvariable variable=ARM_TENANT_ID]$tenantId"
          addSpnToEnvironment: true
       - task: TerraformTaskV4@4
         displayName: Plan
         condition: succeeded()
         inputs:
          provider: 'azurerm'
          command: 'plan'
          workingDirectory: '$(terraformWorkingDirectory)'
          environmentServiceNameAzureRM: '$(serviceConnection)'
          commandOptions: '-parallelism=1 -var resource_name_prefix=$(azureprefix) -var resource_group_name=$(azurergname) -var client_id=$(ARM_CLIENT_ID) -var client_secret=$(ARM_CLIENT_SECRET) -var tenant_id=$(ARM_TENANT_ID)'
    - job: manualValidation
      displayName: Manual validation for checking if the terraform plan is correct
      dependsOn: setup
      pool: server
      steps:
       - task: ManualValidation@0
         displayName: Wait for external validation
         inputs:
           # notifyUsers: aze@umbraco.dk
           instructions: 'Please validate that the terraform plan is correct'
    - job: apply
      displayName: Terraform apply
      dependsOn: 
        - setup
        - manualValidation 
      steps:
      # We need to initialize again, otherwise the pipeline will fail.
      - task: PowerShell@2
        displayName: Terraform Init
        inputs:
          targetType: 'inline'
          script: 'terraform init -backend=false'
          workingDirectory: '$(terraformWorkingDirectory)'
      - task: AzureCLI@2
        name: AzLoginInfo
        displayName: Gets Azure Login Credentials 
        inputs:
         azureSubscription: '$(serviceConnection)'
         scriptType: bash
         scriptLocation: inlineScript
         inlineScript: |
          echo "##vso[task.setvariable variable=ARM_CLIENT_ID]$servicePrincipalId" 
            
          echo "##vso[task.setvariable variable=ARM_CLIENT_SECRET]$servicePrincipalKey"

          echo "##vso[task.setvariable variable=ARM_TENANT_ID]$tenantId"
         addSpnToEnvironment: true
      - task: TerraformTaskV4@4
        displayName: Apply
        inputs:
          provider: 'azurerm'
          command: 'apply'
          workingDirectory: '$(terraformWorkingDirectory)'
          environmentServiceNameAzureRM: '$(serviceConnection)'
          commandOptions: '-parallelism=1 -var resource_name_prefix=$(azureprefix) -var resource_group_name=$(azurergname) -var client_id=$(ARM_CLIENT_ID) -var client_secret=$(ARM_CLIENT_SECRET) -var tenant_id=$(ARM_TENANT_ID)'
      - task: TerraformTaskV4@4
        displayName: 'Terraform Outputs'
        inputs:
          provider: 'azurerm'
          command: 'output'
          workingDirectory: '$(terraformWorkingDirectory)'
          environmentServiceNameAzureRM: '$(serviceConnection)'
      - task: PowerShell@2
        displayName: Terraform Output get hostnames 
        condition: succeededOrFailed()
        inputs:
          targetType: 'inline'
          script: |

            Write-Host "##vso[task.setvariable variable=hostName]$(terraform output -json umbraco_version_hostnames)"

            echo "##vso[task.setvariable variable=hostNames]$(terraform output -json umbraco_version_hostnames)"

            Write-Host "##vso[task.setvariable variable=hosterNames]$(terraform output umbraco_version_hostnames)"

            echo "##vso[task.setvariable variable=hosterName]$(terraform output umbraco_version_hostnames)"
        
          workingDirectory: '$(terraformWorkingDirectory)'
        
      - task: PowerShell@2
        displayName: Write Output
        condition: succeededOrFailed()
        inputs:
          targetType: 'inline'
          script: |
            Write-Host "hostName $(hostName.0)"
            echo "hostNames $(hostNames.0)"
            Write-Host "hosterNames $(hosterNames.0)"
            echo "hosterName $(hosterName.0)"
      - task: PowerShell@2
        name: outputVars
        displayName: Terraform Output get loadTestName 
        condition: succeededOrFailed()
        inputs:
          targetType: 'inline'
          script: |

            Write-Host "##vso[task.setvariable variable=loadertesterName]$(terraform output -json load_test_name)"

            echo "##vso[task.setvariable variable=loadertester]$(terraform output -json load_test_name)"

            Write-Host "##vso[task.setvariable variable=loadName]$(terraform output load_test_name)"

            echo "##vso[task.setvariable variable=loadertesta]$(terraform output load_test_name)"
        
            Write-Host "##vso[task.setvariable variable=loadertesterName;isOutput=true]$(terraform output -json load_test_name)"

            echo "##vso[task.setvariable variable=loadertester;isOutput=true]$(terraform output -json load_test_name)"

            Write-Host "##vso[task.setvariable variable=loadName;isOutput=true]$(terraform output load_test_name)"

            echo "##vso[task.setvariable variable=loadertesta;isOutput=true]$(terraform output load_test_name)"
          workingDirectory: '$(terraformWorkingDirectory)'
   #   - task: PowerShell@2
   #     displayName: Write Output
   #     condition: succeededOrFailed()
   #     inputs:
   #       targetType: 'inline'
   #      script: |
   #          Write-Host "loadertesterName $(loadertesterName)"
   #         Write-Host "loadertester $(loadertester)"
   #         Write-Host "loadName $(loadName)"
   #         Write-Host "loadertesta $(loadertesta)"

 #     - task: Bash@3
 #       displayName: Output to Variable
 #       condition: succeededOrFailed()
  #      inputs:
  #        targetType: 'inline'
  #        script: |
  #         echo "loadertesterName $(loadertesterName)"

     # Remove this manual validation step after the load tests have been set up correctly
    - job: manualValidationLoadTest
      displayName: Manual validation for running load tests
      dependsOn: apply
      condition: succeededOrFailed()
      pool: server
      variables:
        loadTestName: $[ dependencies.apply.outputs['outputVars.loadertesterName'] ]
      steps:
       - task: ManualValidation@0
         displayName: Wait for external validation
         inputs:
           # notifyUsers: aze@umbraco.dk
           instructions: 'Please validate that the terraform has applied as intended before running the load tests on the load test resource $(loadTestName)'
    # At the moment the load test will only be able to test two host names. If you want to extend it to three or four, just add another task with AzureLoadTest. 
    - job: runLoadTest
      displayName: Runs the load test
      dependsOn: manualValidationLoadTest
      steps:
      - task: AzureLoadTest@1
        displayName: LoadTest
        inputs:
          azureSubscription: '$(serviceConnection)'
          loadTestConfigFile: '$(loadTestFileLocation)'
          resourceGroup: '$(azurergname)'
          loadTestResource: 'azure-load-testing-umbraco-loadtest-v10'
          loadTestRunName: 'LoadTesting'
          loadTestRunDescription: 'We are load testing different versions of Umbraco'
          env: |
            [
              {
              "name": "hostName",
              "value": "azure-load-testing-umbraco-appservice-v10.azurewebsites.net"
              }
            ]
      - task: AzureLoadTest@1
        displayName: LoadTest
        inputs:
          azureSubscription: '$(serviceConnection)'
          loadTestConfigFile: '$(loadTestFileLocation)'
          resourceGroup: '$(azurergname)'
          loadTestResource: 'azure-load-testing-umbraco-loadtest-v10'
          loadTestRunName: 'LoadTesting'
          loadTestRunDescription: 'We are load testing different versions of Umbraco'
          env: |
            [
              {
              "name": "hostName",
              "value": "azure-load-testing-umbraco-appservice-v10.azurewebsites.net"
              }
            ]
  
      # Im not really sure how we will be able to run the load test properly. The issue is that we can have as many app servies as we want, and we create the same amount of load tests. But I'm not sure how to update each of the
      # Load test with the correct values aswell as inputting the correct domain name in each of them. 
      #- task: AzureLoadTest@1
      #  inputs:
      #    azureSubscription: '$(serviceConnection)'
      #    loadTestConfigFile: '$(terraformWorkingDirectory)/LoadTestVersions.yaml'
      #    resourceGroup: '$(azurergname)'
      #    loadTestRunName: 'CompareVersions'
      #    loadTestRunDescription: 'We are  load testing different versions of Umbraco'

    - job: doesResourceGroupExists
      displayName: Checks if resource group exists
      dependsOn: runLoadTest
      condition: succeededOrFailed()
      steps:
       - task: AzureCLI@2
         name: checkResourceGroup
         displayName: Checks if the resource group exists
         inputs:
           azureSubscription: 'terraform-umbraco-load-testing-az-connection'
           scriptType: 'pscore'
           scriptLocation: 'inlineScript'
           inlineScript: 'Write-Host "##vso[task.setvariable variable=doesExist;isOutput=true]$(az group exists -n $(azurergname))"'
          
    - job: manualValidationResourceGroup
      dependsOn: doesResourceGroupExists
      condition: eq(dependencies.doesResourceGroupExists.outputs['checkResourceGroup.doesExist'], true)
      variables:
        doesResourceGroupExistVar: $[ dependencies.doesResourceGroupExists.outputs['checkResourceGroup.doesExist'] ]
      displayName: Manual validation for deleting the resource group
      pool: server
      steps:
       - task: ManualValidation@0
         displayName: Wait for external validation
         inputs:
           # notifyUsers: aze@umbraco.dk
           instructions: 'Please validate if you want to delete the resource group with the name of $(azurergname). $(doesResourceGroupExistVar) All the content inside of the resource group will also be deleted.'

    - job: deleteResourceGroup
      displayName: Deletes the resource group
      dependsOn: manualValidationResourceGroup
      condition: succeeded()
      steps:
      - task: AzureCLI@2
        displayName: Deletes the resource group
        inputs:
          azureSubscription: 'terraform-umbraco-load-testing-az-connection'
          scriptType: 'pscore'
          scriptLocation: 'inlineScript'
          inlineScript: 'az group delete -n $(azurergname)'
       
# Steps for the future. An delete resoruce group stage.
  # This stage will run if something fails, also at the end of the pipeline.
  # Manual Validation step before(Just for safety).
  # It will start by checking if the resource group actually exists. Then it will delete the created resource group